<!DOCTYPE HTML>
<html>
    <head>
        <link rel="Stylesheet" type="text/css" href="/static/css/style.css">
        <link rel="Stylesheet" type="text/css" href="/static/css/tango.css">
        <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
        <link rel="icon" href="/favicon.ico" type="image/x-icon">
        <title>C 语言标准库函数 - 老顽童的wiki</title>
        <meta name="keywords" content="wiki, python, machine learning"/>
        <meta name="description" content="wiki-zhb is a wiki for zhbzz2007."/>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    </head>

    <body>
        <div id="container">
            
<div id="header">
  <div id="post-nav"><a href="/">Home</a>&nbsp;»&nbsp;<a href="/#C-and-Cpp">C-and-Cpp</a>&nbsp;»&nbsp;C 语言标准库函数</div>
</div>
<div class="clearfix"></div>
<div id="title">C 语言标准库函数</div>
  <div id="content">
  <p>笔记涵盖C语言标准库的15个头文件解释以及相应函数，持续更新。</p>
<h2 id="1">1.<assert.h> 断言</h2>
<p>头文件<assert.h>提供了宏assert的定义，如果断言不为真，则程序会在标准错误流输出提示信息，并使程序异常中止，调用abort()。</p>
<p>demo：</p>
<div class="hlcode"><pre><span class="cp">#include &lt;assert.h&gt;</span>
<span class="cp">#include &lt;stdio.h&gt;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">12</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">b</span> <span class="o">=</span> <span class="mi">24</span><span class="p">;</span>
    <span class="n">assert</span><span class="p">(</span><span class="n">a</span> <span class="o">&gt;</span> <span class="n">b</span><span class="p">);</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;a is smaller than b!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>


<p>output：</p>
<div class="hlcode"><pre><span class="nx">test</span><span class="o">-</span><span class="nx">c</span><span class="o">-</span><span class="kd">function</span><span class="p">.</span><span class="nx">out</span><span class="o">:</span> <span class="nx">test</span><span class="o">-</span><span class="nx">c</span><span class="o">-</span><span class="kd">function</span><span class="p">.</span><span class="nx">cpp</span><span class="o">:</span><span class="mi">8</span><span class="o">:</span> <span class="kr">int</span> <span class="nx">main</span><span class="p">()</span><span class="o">:</span> <span class="nx">Assertion</span> <span class="err">‘</span><span class="nx">a</span> <span class="o">&gt;</span> <span class="nx">b</span><span class="err">&#39;</span> <span class="nx">failed</span><span class="p">.</span>
<span class="err">已放弃</span> <span class="p">(</span><span class="err">核心已转储</span><span class="p">)</span>
</pre></div>


<p>上面的程序中止，printf函数并未执行，且有这样的输出，int main(): Assertion ’a &gt; b' failed.，原因就是因为a其实小于b，导致断言失败，assert输出错误信息，并调用abort()中止了程序的运行。</p>
<p>将 assert(a &gt; b); 修改为assert(a &lt;= b);</p>
<p>output:</p>
<div class="hlcode"><pre><span class="n">a</span> <span class="n">is</span> <span class="n">smaller</span> <span class="n">than</span> <span class="n">b</span><span class="o">!</span>
</pre></div>


<p>正常输出了printf的内容。</p>
<h2 id="2">2.<ctype.h> 字符测试</h2>
<p><ctype.h> 主要提供两类函数：字符测试函数和字符大小转换函数，提供的函数中都是以int类型为参数，并返回一个int类型的值，实参类型应该隐式转换或者显式转换为int类型。</p>
<p>1.islanum</p>
<p>定义：int isalnum(int c)，判断是否是字母或者数字。</p>
<p>2.isalpha</p>
<p>定义：int isalpha(int c),判断是否是字母。</p>
<p>3.iscntrl</p>
<p>定义：int iscntrl(int c),判断是否是控制字符。</p>
<p>4.isdigit</p>
<p>定义：int isdigit(int c)，判断是否是数字。</p>
<p>5.isgraph</p>
<p>定义：int isgraph(int c)，判断是否是可显示字符。</p>
<p>6.islower</p>
<p>定义：int islower(int c)，判断是否是小写字母。</p>
<p>7.isupper</p>
<p>定义：int isupper(int c)，判断是否是大写字母。</p>
<p>8.isprint</p>
<p>定义：int isprint(int c)，判断是否是可显示字符。</p>
<p>9.ispunct</p>
<p>定义：int ispunct(int c)，判断是否是标点字符。</p>
<p>10.issapce</p>
<p>定义：int isspace(int c)，判断是否是空白字符。</p>
<p>11.isxdigit</p>
<p>定义：int isxdigit(int c)，判断字符是否是16进制。</p>
<p>12.tolower</p>
<p>定义：int tolower(int c)，转换为小写字母。</p>
<p>13.toupper</p>
<p>定义：int toupper(int c)，转换为大小字母。</p>
<h2 id="3">3.<errno.h> 错误代码</h2>
<p><errno.h> 定义了通过错误码来返回错误信息的宏，errno 宏定义为一个int形态的左值，包含任何函数使用errno功能所产生的上一个错误码。</p>
<p>一些表示错误码，定义为整数值的宏：</p>
<p>EDOM，源自于函数的参数超出范围;</p>
<p>ERANGE，源自于函数的结果超出范围;</p>
<p>EILSEQ，源自于不合法的字符顺序;</p>
<h2 id="4">4.<float.h>浮点数运算</h2>
<p><float.h>定义了浮点数值的最大最小限，浮点型数值以下面的方式定义：符号-value E 指数  符号是正负，value是数字的值。</p>
<p>下面的值是用#define定义，所有实例里FLT指的是float，DBL是double，LDBL指的是long double。</p>
<p>FLT_ROUNDS：定义浮点型数值四舍五入的方式，-1是不确定，0是向0,1是向最近，2是向正无穷大，3是负无穷大。</p>
<p>FLT_RADIX 2：定义指数的基本表示（比如base-2是二进制，base-10是十进制，base-16是十六进制）。</p>
<p>FLT_MANT_DIG，DBL_MANT_DIG，LDBL_MANT_DIG：定义数值里数字的个数。</p>
<p>FLT_DIG 6，DBL_DIG 10,LDBL_DIG 10：再四舍五入之后能不更改表示的最大小数位。</p>
<p>FLT_MIN_EXP，DBL_MIN_EXP，LDBL_MIN_EXP：FLT_RADIX的指数的最小负整数值。</p>
<p>FLT_MIN_10_EXP -37,DBL_MIN_10_EXP -37,LDBL_MIN_10_EXP -37：10进制表示法的指数的最小负整数值。</p>
<p>FLT_MAX_EXP，DBL_MAX_EXP，LDBL_MAX_EXP：FLT_RADIX的指数的最大整数值。</p>
<p>FLT_MAX_10_EXP +37,DBL_MAX_10_EXP +37,LDBL_MAX_10_EXP +37：10进制表示法的指数的最大整数值。</p>
<p>FLT_MAX 1E+37,DBL_MAX 1E+37，LDBL_MAX 1E+37：浮点型的最大限。</p>
<p>FLT_EPSILON 1E-5,DBL_EPSILON 1E-9,LDBL_EPSILON 1E-9：能表示的最小有符号数。</p>
<h2 id="5">5.<limits.h>取值范围</h2>
<p>CHAR_BIT：一个ASCII字符长度。</p>
<p>SCHAR_MIN：字符型最小值。</p>
<p>SCHAR_MAX：字符型最大值。</p>
<p>UCHAR_MAX：无符号字符型最大值。</p>
<p>CHAR_MIN，CHAR_MAX：char字符的最小最大值，如果char字符表示有符号整数，那么它们的值就和有符号整数一样，否则char字符的最小值就是0,最大值就是无符号char字符的最大值。</p>
<p>MB_LEN_MAX：一个祖父所占最大字节数。</p>
<p>SHRT_MIN：最小短整型。</p>
<p>SHRT_MAX：最大短整型。</p>
<p>USHRT_MAX：最大无符号短整型。</p>
<p>INT_MIN：最小整型。</p>
<p>INT_MAX：最大整型。</p>
<p>UINT_MIN：最大无符号整型。</p>
<p>LONG_MIN：最小长整型。</p>
<p>LONG_MAX：最大长整型。</p>
<p>ULONG_MAX：无符号长整型。</p>
<h2 id="6">6.<locale.h>本地化</h2>
<p><locale.h>定义了区域设置相关的函数。</p>
<p>setlocale函数：用于设置或返回当前的区域特性。</p>
<p>定义:setlocale(constant,location)</p>
<p>constant：指定设置的场景信息。</p>
<p>location：指定需要进行场景设置的国家或区域。</p>
<p>localeconv函数：用于返回当前区域中的数字和货币信息（保存在struct lconv结构实例中）。</p>
<p>定义:struct lconv * localeconv(void)</p>
<h2 id="7">7.<math.h>数学函数</h2>
<p><math.h>是C语言中的数学函数库。</p>
<p><strong>三角函数：</strong></p>
<p>double sin(double x)：正弦</p>
<p>double cos(double x)：余弦</p>
<p>double tan(double x)：正切</p>
<p><strong>反三角函数：</strong></p>
<p>double asin(double x)：反正弦，结果介于[-PI/2,PI/2]</p>
<p>double acos(double x)：反余弦，结果介于[0,PI]</p>
<p>double atan(double x)：反正切（主值），结果介于[-PI/2,PI/2]</p>
<p>double atan2(double y,double)：反正切（整圆值），结果介于[-PI，PI]</p>
<p><strong>双曲三角函数：</strong></p>
<p>double sinh(double x)：计算双曲正弦</p>
<p>double cosh(double x)：计算双曲余弦</p>
<p>double tanh(double x)：计算双曲正切</p>
<p><strong>指数和对数：</strong></p>
<p>double exp(double x)：求取自然数e的幂</p>
<p>double sqrt(double x)：开平方</p>
<p>double log(double x)：以e为底的对数</p>
<p>double log10(double x)：以10为底的对数</p>
<p>double pow(double x,double y)：计算以x为底的y次幂</p>
<p>float powf(float x,float y)：与pow一致，输入与输出皆为浮点数</p>
<p><strong>取整：</strong></p>
<p>double ceil(double x)：向上取整</p>
<p>double floor(double x)：向下取整</p>
<p><strong>标准化浮点数：</strong></p>
<p>double frexq(double f,int *p)：标准化浮点数，f = x * 2^p，已知f求x，p（x介于[0.5,1]）</p>
<p>double ldexp(double x,int p)：与frexp相反，已知x，p求f</p>
<p><strong>取整与取余：</strong></p>
<p>double modf(double x,double *y)：将参数的整数部分通过指针回传，返回小数部分</p>
<p>double fmod(double x,double y)：返回两个参数相除的余数</p>
<h2 id="8">8.<setjmp.h></h2>
<p><setjmp.h>中定义了一种特别的函数调用和函数返回顺序的方式，允许程序流程立即从一个深层嵌套的函数中返回。</p>
<p>int setjmp(jmp_buf env)：设置跳转点，将当前程序的状态保存在结构env，为调用宏longjmp设置一个跳转点。</p>
<p>longjmp(jmp_buf env,int retval)：跳转，利用setjmp设置的env变量进行跳转，程序会自动跳转到setjmp宏的返回语句处，返回值为retval。</p>
<p>一般，宏setjmp和longjmp是成对使用，这样程序流程可以从一个深层嵌套的函数中返回。</p>
<h2 id="9">9.<signal.h></h2>
<p><signal.h>头文件中，提供了一些函数用以处理执行过程中所产生的信号。</p>
<p>typedef sig_atomic_t</p>
<p>sig_atomic_t：类型是int类型，用于接受signal函数的返回值</p>
<p><strong>宏：</strong></p>
<p>以SIG_开头的宏用于定义信号处理函数，</p>
<p>SIG_DFL：默认信号处理函数</p>
<p>SIG_ERR：表示一个错误信号，当signal函数调用失败时的返回值</p>
<p>SIG_IGN：信号处理函数，表示忽略该信号</p>
<p>SIG开头的宏是用来在下列情况下，用于表示一个信号代码，</p>
<p>SIGABRT：异常中止（abort函数产生）</p>
<p>SIGFPE：浮点错误（0作为除数产生的错误，非法的操作）</p>
<p>SIGILL：非法错误（指令）</p>
<p>SIGINT：交互式操作产生的信号（如CRTL+C）</p>
<p>SIGSEGV：无效访问存储（片段的非法访问，内存非法访问）</p>
<p>SIGTERM：终止请求</p>
<p><strong>函数：</strong></p>
<p>void (*signal(int sig,void (*func)(int))) (int):sig表示一个信号代码，即上面所定义的SIG开头的宏，当有信号出现的时候，参数func所定义的函数就会被调用。</p>
<p>如果func等于SIG_DFL，则表示调用默认的处理函数;</p>
<p>如果等于SIG_IGN，则表示这个信号被忽略（不做处理）;</p>
<p>如果func是用户自定义的函数，则会先调用默认的处理函数，然后再调用用户自定义的函数。自定义函数，有意额参数，参数类型为int，用来表示信号代码，同时，函数必须以return,abort,exit或longjmp等语句结束。当自定义函数运行结束，程序会继续从被终止的地方继续运行。（除非信号是SIGFPE导致结果未定义，则可能无法继续运行）</p>
<p>如果调用signal函数成功，则会返回一个指针，该指针指向为所指定的信号类别的所预先定义的信号处理器。</p>
<p>如果调用失败，则返回一个SIG_ERR，同时errno的值也会被相应的改变。</p>
<p>int raise(int sig)：发送一个sig，信号参数为SIG开头的宏。</p>
<p>如果调用成功，返回0,否则返回一个非零值。</p>
</div>

        </div>
        <div id="footer">
            <span>
                Copyright © 2016 zhbzz2007.
                Powered by <a href="http://simiki.org/" target="_blank">Simiki</a>.
            </span>
        </div>
        
    </body>
</html>