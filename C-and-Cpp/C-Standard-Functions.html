<!DOCTYPE HTML>
<html>
    <head>
        <link rel="Stylesheet" type="text/css" href="/static/css/style.css">
        <link rel="Stylesheet" type="text/css" href="/static/css/tango.css">
        <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
        <link rel="icon" href="/favicon.ico" type="image/x-icon">
        <title>C 语言标准库函数 - 老顽童的wiki</title>
        <meta name="keywords" content="wiki, python, machine learning"/>
        <meta name="description" content="wiki-zhb is a wiki for zhbzz2007."/>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    </head>

    <body>
        <div id="container">
            
<div id="header">
  <div id="post-nav"><a href="/">Home</a>&nbsp;»&nbsp;<a href="/#C-and-Cpp">C-and-Cpp</a>&nbsp;»&nbsp;C 语言标准库函数</div>
</div>
<div class="clearfix"></div>
<div id="title">C 语言标准库函数</div>
  <div id="content">
  <p>笔记涵盖C语言标准库的15个头文件解释以及相应函数，持续更新。</p>
<h2 id="1asserth">1.assert.h 断言</h2>
<p>assert.h 提供了宏assert的定义，如果断言不为真，则程序会在标准错误流输出提示信息，并使程序异常中止，调用abort()。</p>
<p>demo：</p>
<div class="hlcode"><pre><span class="cp">#include &lt;assert.h&gt;</span>
<span class="cp">#include &lt;stdio.h&gt;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">12</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">b</span> <span class="o">=</span> <span class="mi">24</span><span class="p">;</span>
    <span class="n">assert</span><span class="p">(</span><span class="n">a</span> <span class="o">&gt;</span> <span class="n">b</span><span class="p">);</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;a is smaller than b!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>


<p>output：</p>
<div class="hlcode"><pre><span class="nx">test</span><span class="o">-</span><span class="nx">c</span><span class="o">-</span><span class="kd">function</span><span class="p">.</span><span class="nx">out</span><span class="o">:</span> <span class="nx">test</span><span class="o">-</span><span class="nx">c</span><span class="o">-</span><span class="kd">function</span><span class="p">.</span><span class="nx">cpp</span><span class="o">:</span><span class="mi">8</span><span class="o">:</span> <span class="kr">int</span> <span class="nx">main</span><span class="p">()</span><span class="o">:</span> <span class="nx">Assertion</span> <span class="err">‘</span><span class="nx">a</span> <span class="o">&gt;</span> <span class="nx">b</span><span class="err">&#39;</span> <span class="nx">failed</span><span class="p">.</span>
<span class="err">已放弃</span> <span class="p">(</span><span class="err">核心已转储</span><span class="p">)</span>
</pre></div>


<p>上面的程序中止，printf函数并未执行，且有这样的输出，int main(): Assertion ’a &gt; b' failed.，原因就是因为a其实小于b，导致断言失败，assert输出错误信息，并调用abort()中止了程序的运行。</p>
<p>将 assert(a &gt; b); 修改为assert(a &lt;= b);</p>
<p>output:</p>
<div class="hlcode"><pre><span class="n">a</span> <span class="n">is</span> <span class="n">smaller</span> <span class="n">than</span> <span class="n">b</span><span class="o">!</span>
</pre></div>


<p>正常输出了printf的内容。</p>
<h2 id="2ctypeh">2.ctype.h 字符测试</h2>
<p>ctype.h 主要提供两类函数：字符测试函数和字符大小转换函数，提供的函数中都是以int类型为参数，并返回一个int类型的值，实参类型应该隐式转换或者显式转换为int类型。</p>
<p>1.islanum</p>
<p>定义：int isalnum(int c)，判断是否是字母或者数字。</p>
<p>2.isalpha</p>
<p>定义：int isalpha(int c),判断是否是字母。</p>
<p>3.iscntrl</p>
<p>定义：int iscntrl(int c),判断是否是控制字符。</p>
<p>4.isdigit</p>
<p>定义：int isdigit(int c)，判断是否是数字。</p>
<p>5.isgraph</p>
<p>定义：int isgraph(int c)，判断是否是可显示字符。</p>
<p>6.islower</p>
<p>定义：int islower(int c)，判断是否是小写字母。</p>
<p>7.isupper</p>
<p>定义：int isupper(int c)，判断是否是大写字母。</p>
<p>8.isprint</p>
<p>定义：int isprint(int c)，判断是否是可显示字符。</p>
<p>9.ispunct</p>
<p>定义：int ispunct(int c)，判断是否是标点字符。</p>
<p>10.issapce</p>
<p>定义：int isspace(int c)，判断是否是空白字符。</p>
<p>11.isxdigit</p>
<p>定义：int isxdigit(int c)，判断字符是否是16进制。</p>
<p>12.tolower</p>
<p>定义：int tolower(int c)，转换为小写字母。</p>
<p>13.toupper</p>
<p>定义：int toupper(int c)，转换为大小字母。</p>
<h2 id="3errnoh">3.errno.h 错误代码</h2>
<p>errno.h 定义了通过错误码来返回错误信息的宏，errno 宏定义为一个int形态的左值，包含任何函数使用errno功能所产生的上一个错误码。</p>
<p>一些表示错误码，定义为整数值的宏：</p>
<p>EDOM，源自于函数的参数超出范围;</p>
<p>ERANGE，源自于函数的结果超出范围;</p>
<p>EILSEQ，源自于不合法的字符顺序;</p>
<h2 id="4floath">4.float.h 浮点数运算</h2>
<p>float.h 定义了浮点数值的最大最小限，浮点型数值以下面的方式定义：符号-value E 指数  符号是正负，value是数字的值。</p>
<p>下面的值是用#define定义，所有实例里FLT指的是float，DBL是double，LDBL指的是long double。</p>
<p>FLT_ROUNDS：定义浮点型数值四舍五入的方式，-1是不确定，0是向0,1是向最近，2是向正无穷大，3是负无穷大。</p>
<p>FLT_RADIX 2：定义指数的基本表示（比如base-2是二进制，base-10是十进制，base-16是十六进制）。</p>
<p>FLT_MANT_DIG，DBL_MANT_DIG，LDBL_MANT_DIG：定义数值里数字的个数。</p>
<p>FLT_DIG 6，DBL_DIG 10,LDBL_DIG 10：再四舍五入之后能不更改表示的最大小数位。</p>
<p>FLT_MIN_EXP，DBL_MIN_EXP，LDBL_MIN_EXP：FLT_RADIX的指数的最小负整数值。</p>
<p>FLT_MIN_10_EXP -37,DBL_MIN_10_EXP -37,LDBL_MIN_10_EXP -37：10进制表示法的指数的最小负整数值。</p>
<p>FLT_MAX_EXP，DBL_MAX_EXP，LDBL_MAX_EXP：FLT_RADIX的指数的最大整数值。</p>
<p>FLT_MAX_10_EXP +37,DBL_MAX_10_EXP +37,LDBL_MAX_10_EXP +37：10进制表示法的指数的最大整数值。</p>
<p>FLT_MAX 1E+37,DBL_MAX 1E+37，LDBL_MAX 1E+37：浮点型的最大限。</p>
<p>FLT_EPSILON 1E-5,DBL_EPSILON 1E-9,LDBL_EPSILON 1E-9：能表示的最小有符号数。</p>
<h2 id="5limitsh">5.limits.h 取值范围</h2>
<p>CHAR_BIT：一个ASCII字符长度。</p>
<p>SCHAR_MIN：字符型最小值。</p>
<p>SCHAR_MAX：字符型最大值。</p>
<p>UCHAR_MAX：无符号字符型最大值。</p>
<p>CHAR_MIN，CHAR_MAX：char字符的最小最大值，如果char字符表示有符号整数，那么它们的值就和有符号整数一样，否则char字符的最小值就是0,最大值就是无符号char字符的最大值。</p>
<p>MB_LEN_MAX：一个祖父所占最大字节数。</p>
<p>SHRT_MIN：最小短整型。</p>
<p>SHRT_MAX：最大短整型。</p>
<p>USHRT_MAX：最大无符号短整型。</p>
<p>INT_MIN：最小整型。</p>
<p>INT_MAX：最大整型。</p>
<p>UINT_MIN：最大无符号整型。</p>
<p>LONG_MIN：最小长整型。</p>
<p>LONG_MAX：最大长整型。</p>
<p>ULONG_MAX：无符号长整型。</p>
<h2 id="6localeh">6.locale.h 本地化</h2>
<p>locale.h 定义了区域设置相关的函数。</p>
<p>setlocale函数：用于设置或返回当前的区域特性。</p>
<p>定义:setlocale(constant,location)</p>
<p>constant：指定设置的场景信息。</p>
<p>location：指定需要进行场景设置的国家或区域。</p>
<p>localeconv函数：用于返回当前区域中的数字和货币信息（保存在struct lconv结构实例中）。</p>
<p>定义:struct lconv * localeconv(void)</p>
<h2 id="7mathh">7.math.h 数学函数</h2>
<p>math.h 是C语言中的数学函数库。</p>
<p><strong>三角函数：</strong></p>
<p>double sin(double x)：正弦;</p>
<p>double cos(double x)：余弦;</p>
<p>double tan(double x)：正切;</p>
<p><strong>反三角函数：</strong></p>
<p>double asin(double x)：反正弦，结果介于[-PI/2,PI/2];</p>
<p>double acos(double x)：反余弦，结果介于[0,PI];</p>
<p>double atan(double x)：反正切（主值），结果介于[-PI/2,PI/2];</p>
<p>double atan2(double y,double)：反正切（整圆值），结果介于[-PI，PI];</p>
<p><strong>双曲三角函数：</strong></p>
<p>double sinh(double x)：计算双曲正弦;</p>
<p>double cosh(double x)：计算双曲余弦;</p>
<p>double tanh(double x)：计算双曲正切;</p>
<p><strong>指数和对数：</strong></p>
<p>double exp(double x)：求取自然数e的幂;</p>
<p>double sqrt(double x)：开平方;</p>
<p>double log(double x)：以e为底的对数;</p>
<p>double log10(double x)：以10为底的对数;</p>
<p>double pow(double x,double y)：计算以x为底的y次幂;</p>
<p>float powf(float x,float y)：与pow一致，输入与输出皆为浮点数;</p>
<p><strong>取整：</strong></p>
<p>double ceil(double x)：向上取整;</p>
<p>double floor(double x)：向下取整;</p>
<p><strong>标准化浮点数：</strong></p>
<p>double frexq(double f,int *p)：标准化浮点数，f = x * 2^p，已知f求x，p（x介于[0.5,1]）;</p>
<p>double ldexp(double x,int p)：与frexp相反，已知x，p求f;</p>
<p><strong>取整与取余：</strong></p>
<p>double modf(double x,double *y)：将参数的整数部分通过指针回传，返回小数部分;</p>
<p>double fmod(double x,double y)：返回两个参数相除的余数;</p>
<h2 id="8setjmph">8.setjmp.h 非局部跳转</h2>
<p>setjmp.h中定义了一种特别的函数调用和函数返回顺序的方式，允许程序流程立即从一个深层嵌套的函数中返回。</p>
<p>int setjmp(jmp_buf env)：设置跳转点，将当前程序的状态保存在结构env，为调用宏longjmp设置一个跳转点。</p>
<p>longjmp(jmp_buf env,int retval)：跳转，利用setjmp设置的env变量进行跳转，程序会自动跳转到setjmp宏的返回语句处，返回值为retval。</p>
<p>一般，宏setjmp和longjmp是成对使用，这样程序流程可以从一个深层嵌套的函数中返回。</p>
<h2 id="9signalh">9.signal.h 信号</h2>
<p>signal.h 头文件中，提供了一些函数用以处理执行过程中所产生的信号。</p>
<p>typedef sig_atomic_t</p>
<p>sig_atomic_t：类型是int类型，用于接受signal函数的返回值;</p>
<p><strong>宏：</strong></p>
<p>以SIG_开头的宏用于定义信号处理函数，</p>
<p>SIG_DFL：默认信号处理函数;</p>
<p>SIG_ERR：表示一个错误信号，当signal函数调用失败时的返回值;</p>
<p>SIG_IGN：信号处理函数，表示忽略该信号;</p>
<p>SIG开头的宏是用来在下列情况下，用于表示一个信号代码，</p>
<p>SIGABRT：异常中止（abort函数产生）;</p>
<p>SIGFPE：浮点错误（0作为除数产生的错误，非法的操作）;</p>
<p>SIGILL：非法错误（指令）;</p>
<p>SIGINT：交互式操作产生的信号（如CRTL+C）;</p>
<p>SIGSEGV：无效访问存储（片段的非法访问，内存非法访问）;</p>
<p>SIGTERM：终止请求;</p>
<p><strong>函数：</strong></p>
<p>void (*signal(int sig,void (*func)(int))) (int):sig表示一个信号代码，即上面所定义的SIG开头的宏，当有信号出现的时候，参数func所定义的函数就会被调用。</p>
<p>如果func等于SIG_DFL，则表示调用默认的处理函数;</p>
<p>如果等于SIG_IGN，则表示这个信号被忽略（不做处理）;</p>
<p>如果func是用户自定义的函数，则会先调用默认的处理函数，然后再调用用户自定义的函数。自定义函数，有意额参数，参数类型为int，用来表示信号代码，同时，函数必须以return,abort,exit或longjmp等语句结束。当自定义函数运行结束，程序会继续从被终止的地方继续运行。（除非信号是SIGFPE导致结果未定义，则可能无法继续运行）</p>
<p>如果调用signal函数成功，则会返回一个指针，该指针指向为所指定的信号类别的所预先定义的信号处理器。</p>
<p>如果调用失败，则返回一个SIG_ERR，同时errno的值也会被相应的改变。</p>
<p>int raise(int sig)：发送一个sig，信号参数为SIG开头的宏。</p>
<p>如果调用成功，返回0，否则返回一个非零值。</p>
<h2 id="10stdargh">10.stdarg.h 可变参数</h2>
<p>stdarg.h 定义了一些宏，当函数参数未知时去获取函数的参数。</p>
<p><strong>变量：</strong></p>
<p>typedef va_list：通过stdarg宏定义来反问一个函数的参数表，参数列表的末尾会用省略号省略。</p>
<p><strong>宏：</strong></p>
<p>void va_start(va_list ap,last_arg)：用va_arg和va_end宏初始化参数ap，last_arg是传给函数的固定参数的最后一个，省略号之前的那个参数，注意va_start必须在va_arg和va_end之前调用;</p>
<p>type va_arg(va_list ap,type)：用type类型扩展到参数表的下个参数，注意，ap必须用va_start初始化，如果没有下一个参数，结果会是undefined;</p>
<p>void va_end(va_list ap)：允许一个有参数表（使用va_start宏）的函数返回，如果返回之前没有调用va_end，结果会是undefined。参数变量列表可能不再使用（在没调用va_staart的情况下va_end）;</p>
<h2 id="11stddefh">11.stddef.h 一些常数，类型和变量</h2>
<p>stddef.h 定义了一些标准定义，许多定义宴会出现在其他的头文件里。</p>
<p><strong>宏：</strong></p>
<p>NULL：空指针的常量值;</p>
<p>offsetof(type,member-designator)：返回一个结构提成员相对于结构体起始地址的偏移量（以字节为单位），type是结构体的名字，member-designator是结构体成员的名字;</p>
<p><strong>变量和定义：</strong></p>
<p>typedef ptrdiff_t：两个指针相减的结果;</p>
<p>typedef size_t：是sizeof一个关键词得到的无符号整数值;</p>
<p>typedef wchar_t：一个宽字符常量的大小，是整数类型;</p>
<h2 id="12stdioh">12.stdio.h 输入和输出</h2>
<p><stdio.h>定义了用于输入和输出的函数、类型和宏。</p>
<p><strong>变量：</strong></p>
<p>typedef FILE：用于声明文件指针;</p>
<p>typedef size_t：是由sizeof产生的无符号整数类型;</p>
<p>typedef fpos_t：能够唯一说明文件中的每个位置的对象;</p>
<p><strong>常量：</strong></p>
<p>NULL：空值;</p>
<p>_IOFBF：表示完全缓冲;</p>
<p>_IOLBF：表示线缓冲;</p>
<p>_IONBF：表示无缓冲;</p>
<p>BUFSIZ：setbuf函数所使用的缓冲区的大小;</p>
<p>EOF：EOF是负整数，表示END OF FILE</p>
<p>FOPEN_MAX：同时打开的文件的最大数量;</p>
<p>FILENAME_MAX：文件名的最大长度;</p>
<p>L_tempnam：整数，最大长度的临时文件名;</p>
<p>SEEK_CUR：取得目前文件位置;</p>
<p>SEEK_END：将读写位置移到文件末尾;</p>
<p>SEEK_SET：将读写位置移到文件开头;</p>
<p>TMP_MAX：tmpnam最多次数;</p>
<p>stderr：标准错误流，默认为屏幕，可输出到文件;</p>
<p>stdin：标准输入流，默认为键盘;</p>
<p>stdout：标准输出流，默认为屏幕;</p>
<p><strong>函数：</strong></p>
<p>clearerr()：复位错误标志;</p>
<p>fclose()：关闭一个文件流;</p>
<p>feof()：检测文件结束符;</p>
<p>ferror()：检查流是否有错误;</p>
<p>fflush()：更新缓冲区;</p>
<p>fgetpos()：移动文件流的读写位置;</p>
<p>fopen()：打开文件;</p>
<p>fread()：从文件流读取数据;</p>
<p>freopen()：打开文件;</p>
<p>fseek()：移动文件流的读写位置;</p>
<p>fsetpos()：定位流上的文件指针;</p>
<p>ftell()：取得文件流的读取位置;</p>
<p>fwrite()：将数据写至文件流;</p>
<p>remove()：删除文件;</p>
<p>rename()：更改文件名称或位置;</p>
<p>rewind()：重设读取目录的位置为开头位置;</p>
<p>setbuf()：把缓冲区与流相联;</p>
<p>setvbuf()：把缓冲区与流相联;</p>
<p>tmpfile()：以wb+形式创建一个临时二进制文件;</p>
<p>tmpnam()：产生一个唯一的文件名;</p>
<p>fprintf()：格式化输出数据至文件;</p>
<p>fscanf()：格式化字符串输入;</p>
<p>printf()：格式化输出数据;</p>
<p>scanf()：格式化输入函数;</p>
<p>sprintf()：格式化字符串复制;</p>
<p>sscanf()：格式化字符串输入;</p>
<p>vfprintf()：格式化输出数据至文件;</p>
<p>vprintf()：格式化输出数据;</p>
<p>vsprintf()：格式化字符串复制;</p>
<p>fgetc()：由文件中读取一个字符;</p>
<p>fgets()：文件中读取一字符串;</p>
<p>fputc()：将一指定字符写入文件流中;</p>
<p>fputs()：将一指定的字符串写入文件内;</p>
<p>getc()：由文件中读取一个字符;</p>
<p>getchar()：由标准输入设备内读进一个字符;</p>
<p>gets()：由标准输入设备内读进一个字符串;</p>
<p>putc()：将一指定字符写入文件中;</p>
<p>putchar()：将指定的字符写道标准内输出设备;</p>
<p>puts()：送一字符串到流stdout中;</p>
<p>ungetc()：将指定字符写回文件流中;</p>
<p>perror()：打印出错误原因信息字符串;</p>
</div>

        </div>
        <div id="footer">
            <span>
                Copyright © 2016 zhbzz2007.
                Powered by <a href="http://simiki.org/" target="_blank">Simiki</a>.
            </span>
        </div>
        
    </body>
</html>