<!DOCTYPE HTML>
<html>
    <head>
        <link rel="Stylesheet" type="text/css" href="/static/css/style.css">
        <link rel="Stylesheet" type="text/css" href="/static/css/tango.css">
        <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
        <link rel="icon" href="/favicon.ico" type="image/x-icon">
        <title>Spark存储管理 - 老顽童的wiki</title>
        <meta name="keywords" content="wiki, python, machine learning"/>
        <meta name="description" content="wiki-zhb is a wiki for zhbzz2007."/>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    </head>

    <body>
        <div id="container">
            
<div id="header">
  <div id="post-nav"><a href="/">Home</a>&nbsp;»&nbsp;<a href="/#Spark">Spark</a>&nbsp;»&nbsp;Spark存储管理</div>
</div>
<div class="clearfix"></div>
<div id="title">Spark存储管理</div>
  <div id="content">
  <h2 id="1">1.存储管理模块整体架构</h2>
<p>从架构上看存储管理模块主要分为以下两层，</p>
<p>通信层：存储管理模块采用的是主从结构来实现通信层，主节点和从节点之间传输控制信息、状态信息；</p>
<p>存储层：存储管理模块需要把数据存储到硬盘或者内存中，必要时还需要复制到远端，这些操作由存储层来实现和提供相应接口；</p>
<p>从功能上看存储管理模块可以分为如下两个主要部分，</p>
<p>RDD缓存：整个存储管理模块主要的工作是作为RDD的缓存，包括基于内存和磁盘的缓存；</p>
<p>Shuffle数据的持久化：Shuffle中间结果的数据也是交由存储管理模块进行管理的。Shuffle性能的好坏直接影响了Spark应用程序整体的性能，因此存储管理模块中对于Shuffle数据的处理有别于传统的RDD缓存；</p>
<p>在存储管理模块中管理着各种不同的数据块，主要有以下几种，</p>
<ol>
<li>RDD数据块：用来标识所缓存的RDD数据；</li>
<li>Shuffle数据块：用来标识所持久化的Shuffle数据；</li>
<li>广播变量数据块：用来标识所存储的广播变量数据；</li>
<li>任务返回结果数据块：用来标识存储在存储管理模块内部的任务返回结果。通常情况下，任务返回结果随任务一起通过Akka返回到Driver端。但是当任务返回结果很大时，会引起Akka帧溢出，这时的另一种方案是将返回结果以块的形式放入存储管理模块，然后在Driver端获取该数据即可，因为存储管理模块内部数据的传输是通过Socket连接的，因此就不会出现Akka帧溢出了；</li>
<li>流式数据块：只用在Spark Streaming中，用来标识所接收到的流式数据块；</li>
</ol>
<h2 id="2rdd">2.RDD持久化</h2>
<h3 id="21rdd">2.1RDD分区和数据块的关系</h3>
<p>对于RDD的各种操作，如转换操作、执行操作，我们将操作函数施行于RDD之上，而最终这些操作都将施行于每一个分区之上，也就是在RDD上的所有运算都是基于分区的。而在存储管理模块内，我们所接触到的往往是数据块这个概念，在存储管理模块中对于数据的存取都是以数据块为单位进行的。分区是一个逻辑上的概念，而数据块是物理上数据实体。</p>
<p>1.在Spark中，分区和数据块是一一对应的，一个RDD中的一个分区对应着存储管理模块中的一个数据块，存储管理模块接触不到也不关心RDD，它只关心数据块，对于数据块和分区之间的映射则是通过名称上的约定进行的；</p>
<p>2.这种名称上的约定是按照如下方式建立的：Spark为每一个RDD在其内部维护了独立的ID号，同时，对于RDD的每一个分区也有一个独立的索引号，因此只要指导ID号和索引号，我们就能找到RDD中的相应分区，也就是说“ID号 + 索引号”就能全局唯一地确定这个分区，这样以“ID号 + 索引号”作为块的名称就自然建立起了分区和块的映射；</p>
<p>在显式调用函数缓存我们所需的RDD时，Spark在其内部建立了RDD分区和数据块之间的映射，而当我们需要读取缓存的RDD时，根据上面的映射关系，就能从存储管理模块中取得分区对应的数据块。</p>
<h3 id="22">2.2内存缓存</h3>
<h3 id="23">2.3硬盘缓存</h3>
<h3 id="24">2.4持久化选项</h3>
<h3 id="25">2.5如何选择不同的持久化选项</h3>
<h2 id="3shuffle">3.Shuffle数据持久化</h2>
<h2 id="4">4.广播变量持久化</h2>
</div>

        </div>
        <div id="footer">
            <span>
                Copyright © 2016 zhbzz2007.
                Powered by <a href="http://simiki.org/" target="_blank">Simiki</a>.
            </span>
        </div>
        
    </body>
</html>